'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.removePoints = exports.addPoints = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _svgArcToCubicBezier = require('svg-arc-to-cubic-bezier');

var _svgArcToCubicBezier2 = _interopRequireDefault(_svgArcToCubicBezier);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

var isBetween = function isBetween(a, b, c) {
  if (b.curve || c.curve) {
    return false;
  }

  var crossProduct = (c.y - a.y) * (b.x - a.x) - (c.x - a.x) * (b.y - a.y);

  if (Math.abs(crossProduct) > Number.EPSILON) {
    return false;
  }

  var dotProduct = (c.x - a.x) * (b.x - a.x) + (c.y - a.y) * (b.y - a.y);

  if (dotProduct < 0) {
    return false;
  }

  var squaredLengthBA = (b.x - a.x) * (b.x - a.x) + (b.y - a.y) * (b.y - a.y);

  if (dotProduct > squaredLengthBA) {
    return false;
  }

  return true;
};

var straightMidPoint = function straightMidPoint(a, b) {
  var x = a.x === b.x ? 0 : Math.abs(b.x - a.x);
  var y = a.y === b.y ? 0 : Math.abs(b.y - a.y);

  return {
    x: x === 0 ? a.x : a.x < b.x ? a.x + x / 2 : a.x - x / 2,
    y: y === 0 ? a.y : a.y < b.y ? a.y + y / 2 : a.y - y / 2
  };
};

var midPoint = function midPoint(a, b) {
  if (!b.curve) {
    return straightMidPoint(a, b);
  }

  return false;
};

var addPoints = function addPoints(points, pointsRequired) {
  var p = [].concat(_toConsumableArray(points));

  for (var i = 1; i < p.length;) {
    var m = midPoint(p[i - 1], p[i]);

    if (m) {
      p.splice(i, 0, m);

      if (p.length === pointsRequired) {
        return p;
      }

      i += 2;
    } else {
      i++;
    }
  }

  if (p.length === points.length) {
    var additionalPoints = pointsRequired - p.length;
    var newPoint = { x: p[0].x, y: p[0].y };

    for (var _i = 0; _i < additionalPoints; _i++) {
      p.unshift(newPoint);
    }

    return p;
  }

  return addPoints(p, pointsRequired);
};

var removePoints = function removePoints(points) {
  var result = [];

  for (var i = 0, l = points.length; i < l; i++) {
    var a = result[result.length - 1];
    var b = points[i + 1];
    var c = points[i];

    if (!(a && b && c) || !isBetween(a, b, c)) {
      result.push(c);
    }
  }

  return result;
};

var matchCurves = function matchCurves(a, b) {
  var c = [];
  var d = [];

  for (var i = 0, l = a.length; i < l; i++) {
    if (a[i].curve && !b[i].curve) {
      c.push(a[i]);
      d.push(_extends({}, b[i], { curve: {
          type: 'cubic',
          x1: b[i - 1].x,
          y1: b[i - 1].y,
          x2: b[i].x,
          y2: b[i].y
        } }));
    } else if (b[i].curve && !a[i].curve) {
      d.push(b[i]);
      c.push(_extends({}, a[i], { curve: {
          type: 'cubic',
          x1: a[i - 1].x,
          y1: a[i - 1].y,
          x2: a[i].x,
          y2: a[i].y
        } }));
    } else {
      c.push(a[i]);
      d.push(b[i]);
    }
  }

  return [c, d];
};

var convertCurvesToCubic = function convertCurvesToCubic(points) {
  var p = [];

  for (var i = 0, l = points.length; i < l; i++) {
    var point = points[i];

    if (point.curve && point.curve.type !== 'cubic') {
      var _points = points[i - 1];
      var px = _points.x;
      var py = _points.y;
      var cx = point.x;
      var cy = point.y;


      if (point.curve.type === 'arc') {
        var curves = (0, _svgArcToCubicBezier2.default)({
          px: px,
          py: py,
          cx: cx,
          cy: cy,
          rx: point.curve.rx,
          ry: point.curve.ry,
          xAxisRotation: point.curve.xAxisRotation,
          largeArcFlag: point.curve.largeArcFlag,
          sweepFlag: point.curve.sweepFlag
        });

        curves.forEach(function (_ref) {
          var x1 = _ref.x1;
          var y1 = _ref.y1;
          var x2 = _ref.x2;
          var y2 = _ref.y2;
          var x = _ref.x;
          var y = _ref.y;

          p.push({ x: x, y: y, curve: { type: 'cubic', x1: x1, y1: y1, x2: x2, y2: y2 } });
        });
      } else if (point.curve.type === 'quadratic') {
        var x1 = px + 2 / 3 * (point.curve.x1 - px);
        var y1 = py + 2 / 3 * (point.curve.y1 - py);
        var x2 = cx + 2 / 3 * (point.curve.x1 - cx);
        var y2 = cy + 2 / 3 * (point.curve.y1 - cy);

        p.push({ x: cx, y: cy, curve: { type: 'cubic', x1: x1, y1: y1, x2: x2, y2: y2 } });
      }
    } else {
      p.push(point);
    }
  }

  return p;
};

var matchPoints = function matchPoints(a, b) {
  var c = convertCurvesToCubic(removePoints(a));
  var d = convertCurvesToCubic(removePoints(b));

  if (d.length > c.length) {
    c = addPoints(c, d.length);
  } else if (c.length > d.length) {
    d = addPoints(d, c.length);
  }

  return matchCurves(c, d);
};

exports.addPoints = addPoints;
exports.removePoints = removePoints;
exports.default = matchPoints;