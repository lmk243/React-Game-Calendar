(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["SVGTween"] = factory();
	else
		root["SVGTween"] = factory();
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.tweenPaths = undefined;

	var _tween = __webpack_require__(1);

	var _tween2 = _interopRequireDefault(_tween);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.tweenPaths = _tween.tweenPaths;
	exports.default = _tween2.default;

/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.tweenPaths = undefined;

	var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

	var _tweening = __webpack_require__(2);

	var _tweening2 = _interopRequireDefault(_tweening);

	var _svgShapes = __webpack_require__(8);

	var _matchPoints3 = __webpack_require__(11);

	var _matchPoints4 = _interopRequireDefault(_matchPoints3);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

	var shapeToPoints = function shapeToPoints(shp) {
	  var shape = shp.shape;

	  var attributes = _objectWithoutProperties(shp, ['shape']);

	  return (0, _svgShapes.getPoints)(shape, attributes);
	};

	var matchPointArrays = function matchPointArrays(a, b) {
	  var x = [];
	  var y = [];

	  for (var i = 0, l = a.length; i < l; i++) {
	    var _matchPoints = (0, _matchPoints4.default)(a[i], b[i]);

	    var _matchPoints2 = _slicedToArray(_matchPoints, 2);

	    var c = _matchPoints2[0];
	    var d = _matchPoints2[1];

	    x.push(c);
	    y.push(d);
	  }

	  return [x, y];
	};

	var tweenPaths = function tweenPaths(_ref) {
	  var complete = _ref.complete;
	  var duration = _ref.duration;
	  var easing = _ref.easing;
	  var from = _ref.from;
	  var next = _ref.next;
	  var to = _ref.to;

	  var f = Array.isArray(from) ? from.map(function (d) {
	    return { shape: 'path', d: d };
	  }) : { shape: 'path', d: from };

	  var t = Array.isArray(to) ? to.map(function (d) {
	    return { shape: 'path', d: d };
	  }) : { shape: 'path', d: to };

	  tween({ complete: complete, duration: duration, easing: easing, from: f, next: next, to: t });
	};

	var tween = function tween(_ref2) {
	  var _complete = _ref2.complete;
	  var duration = _ref2.duration;
	  var easing = _ref2.easing;
	  var from = _ref2.from;
	  var _next = _ref2.next;
	  var to = _ref2.to;

	  var fromShapes = Array.isArray(from) ? from : [from];
	  var toShapes = Array.isArray(to) ? to : [to];

	  var fromPoints = fromShapes.map(shapeToPoints);
	  var toPoints = toShapes.map(shapeToPoints);

	  var _matchPointArrays = matchPointArrays(fromPoints, toPoints);

	  var _matchPointArrays2 = _slicedToArray(_matchPointArrays, 2);

	  var f = _matchPointArrays2[0];
	  var t = _matchPointArrays2[1];


	  (0, _tweening2.default)({
	    complete: function complete() {
	      if (typeof _next === 'function') {
	        toPoints.forEach(function (p, i) {
	          return _next((0, _svgShapes.toPath)(p), i);
	        });
	      }

	      if (typeof _complete === 'function') {
	        _complete();
	      }
	    },
	    duration: duration,
	    easing: easing,
	    from: f,
	    next: function next(points) {
	      if (typeof _next === 'function') {
	        points.forEach(function (p, i) {
	          return _next((0, _svgShapes.toPath)(p), i);
	        });
	      }
	    },
	    to: t
	  });
	};

	exports.tweenPaths = tweenPaths;
	exports.default = tween;

/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _tween = __webpack_require__(3);

	var _tween2 = _interopRequireDefault(_tween);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.default = _tween2.default;

/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _easingFuncFromName = __webpack_require__(4);

	var _easingFuncFromName2 = _interopRequireDefault(_easingFuncFromName);

	var _tweenGenerator = __webpack_require__(6);

	var _tweenGenerator2 = _interopRequireDefault(_tweenGenerator);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var tween = function tween(_ref) {
	  var _ref$duration = _ref.duration;
	  var duration = _ref$duration === undefined ? 200 : _ref$duration;
	  var complete = _ref.complete;
	  var _ref$easing = _ref.easing;
	  var easing = _ref$easing === undefined ? 'easeInOutQuad' : _ref$easing;
	  var from = _ref.from;
	  var next = _ref.next;
	  var to = _ref.to;

	  if (typeof duration !== 'number' || duration <= 0 || duration == Infinity) {
	    throw new Error('Duration must be a positive number less than infinity');
	  }

	  var easingFunc = typeof easing === 'function' ? easing : (0, _easingFuncFromName2.default)(easing);

	  var g = (0, _tweenGenerator2.default)({ duration: duration, easing: easingFunc, from: from, to: to });

	  var animate = function animate() {
	    var _g$next = g.next();

	    var done = _g$next.done;
	    var value = _g$next.value;


	    if (done) {
	      if (typeof next === 'function') {
	        next(to);
	      }

	      if (typeof complete === 'function') {
	        complete();
	      }
	    } else {
	      if (typeof next === 'function') {
	        next(value);
	      }

	      window.requestAnimationFrame(animate);
	    }
	  };

	  window.requestAnimationFrame(animate);
	};

	exports.default = tween;

/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _tweenFunctions = __webpack_require__(5);

	var _tweenFunctions2 = _interopRequireDefault(_tweenFunctions);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var easingFuncFromName = function easingFuncFromName(name) {
	  var func = _tweenFunctions2.default[name];

	  if (typeof func !== 'function') {
	    throw new Error('Easing function ' + name + ' does not exist');
	  }

	  return func;
	};

	exports.default = easingFuncFromName;

/***/ },
/* 5 */
/***/ function(module, exports) {

	'use strict';

	// t: current time, b: beginning value, _c: final value, d: total duration
	var tweenFunctions = {
	  linear: function(t, b, _c, d) {
	    var c = _c - b;
	    return c * t / d + b;
	  },
	  easeInQuad: function(t, b, _c, d) {
	    var c = _c - b;
	    return c * (t /= d) * t + b;
	  },
	  easeOutQuad: function(t, b, _c, d) {
	    var c = _c - b;
	    return -c * (t /= d) * (t - 2) + b;
	  },
	  easeInOutQuad: function(t, b, _c, d) {
	    var c = _c - b;
	    if ((t /= d / 2) < 1) {
	      return c / 2 * t * t + b;
	    } else {
	      return -c / 2 * ((--t) * (t - 2) - 1) + b;
	    }
	  },
	  easeInCubic: function(t, b, _c, d) {
	    var c = _c - b;
	    return c * (t /= d) * t * t + b;
	  },
	  easeOutCubic: function(t, b, _c, d) {
	    var c = _c - b;
	    return c * ((t = t / d - 1) * t * t + 1) + b;
	  },
	  easeInOutCubic: function(t, b, _c, d) {
	    var c = _c - b;
	    if ((t /= d / 2) < 1) {
	      return c / 2 * t * t * t + b;
	    } else {
	      return c / 2 * ((t -= 2) * t * t + 2) + b;
	    }
	  },
	  easeInQuart: function(t, b, _c, d) {
	    var c = _c - b;
	    return c * (t /= d) * t * t * t + b;
	  },
	  easeOutQuart: function(t, b, _c, d) {
	    var c = _c - b;
	    return -c * ((t = t / d - 1) * t * t * t - 1) + b;
	  },
	  easeInOutQuart: function(t, b, _c, d) {
	    var c = _c - b;
	    if ((t /= d / 2) < 1) {
	      return c / 2 * t * t * t * t + b;
	    } else {
	      return -c / 2 * ((t -= 2) * t * t * t - 2) + b;
	    }
	  },
	  easeInQuint: function(t, b, _c, d) {
	    var c = _c - b;
	    return c * (t /= d) * t * t * t * t + b;
	  },
	  easeOutQuint: function(t, b, _c, d) {
	    var c = _c - b;
	    return c * ((t = t / d - 1) * t * t * t * t + 1) + b;
	  },
	  easeInOutQuint: function(t, b, _c, d) {
	    var c = _c - b;
	    if ((t /= d / 2) < 1) {
	      return c / 2 * t * t * t * t * t + b;
	    } else {
	      return c / 2 * ((t -= 2) * t * t * t * t + 2) + b;
	    }
	  },
	  easeInSine: function(t, b, _c, d) {
	    var c = _c - b;
	    return -c * Math.cos(t / d * (Math.PI / 2)) + c + b;
	  },
	  easeOutSine: function(t, b, _c, d) {
	    var c = _c - b;
	    return c * Math.sin(t / d * (Math.PI / 2)) + b;
	  },
	  easeInOutSine: function(t, b, _c, d) {
	    var c = _c - b;
	    return -c / 2 * (Math.cos(Math.PI * t / d) - 1) + b;
	  },
	  easeInExpo: function(t, b, _c, d) {
	    var c = _c - b;
	    return (t==0) ? b : c * Math.pow(2, 10 * (t/d - 1)) + b;
	  },
	  easeOutExpo: function(t, b, _c, d) {
	    var c = _c - b;
	    return (t==d) ? b+c : c * (-Math.pow(2, -10 * t/d) + 1) + b;
	  },
	  easeInOutExpo: function(t, b, _c, d) {
	    var c = _c - b;
	    if (t === 0) {
	      return b;
	    }
	    if (t === d) {
	      return b + c;
	    }
	    if ((t /= d / 2) < 1) {
	      return c / 2 * Math.pow(2, 10 * (t - 1)) + b;
	    } else {
	      return c / 2 * (-Math.pow(2, -10 * --t) + 2) + b;
	    }
	  },
	  easeInCirc: function(t, b, _c, d) {
	    var c = _c - b;
	    return -c * (Math.sqrt(1 - (t /= d) * t) - 1) + b;
	  },
	  easeOutCirc: function(t, b, _c, d) {
	    var c = _c - b;
	    return c * Math.sqrt(1 - (t = t / d - 1) * t) + b;
	  },
	  easeInOutCirc: function(t, b, _c, d) {
	    var c = _c - b;
	    if ((t /= d / 2) < 1) {
	      return -c / 2 * (Math.sqrt(1 - t * t) - 1) + b;
	    } else {
	      return c / 2 * (Math.sqrt(1 - (t -= 2) * t) + 1) + b;
	    }
	  },
	  easeInElastic: function(t, b, _c, d) {
	    var c = _c - b;
	    var a, p, s;
	    s = 1.70158;
	    p = 0;
	    a = c;
	    if (t === 0) {
	      return b;
	    } else if ((t /= d) === 1) {
	      return b + c;
	    }
	    if (!p) {
	      p = d * 0.3;
	    }
	    if (a < Math.abs(c)) {
	      a = c;
	      s = p / 4;
	    } else {
	      s = p / (2 * Math.PI) * Math.asin(c / a);
	    }
	    return -(a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p)) + b;
	  },
	  easeOutElastic: function(t, b, _c, d) {
	    var c = _c - b;
	    var a, p, s;
	    s = 1.70158;
	    p = 0;
	    a = c;
	    if (t === 0) {
	      return b;
	    } else if ((t /= d) === 1) {
	      return b + c;
	    }
	    if (!p) {
	      p = d * 0.3;
	    }
	    if (a < Math.abs(c)) {
	      a = c;
	      s = p / 4;
	    } else {
	      s = p / (2 * Math.PI) * Math.asin(c / a);
	    }
	    return a * Math.pow(2, -10 * t) * Math.sin((t * d - s) * (2 * Math.PI) / p) + c + b;
	  },
	  easeInOutElastic: function(t, b, _c, d) {
	    var c = _c - b;
	    var a, p, s;
	    s = 1.70158;
	    p = 0;
	    a = c;
	    if (t === 0) {
	      return b;
	    } else if ((t /= d / 2) === 2) {
	      return b + c;
	    }
	    if (!p) {
	      p = d * (0.3 * 1.5);
	    }
	    if (a < Math.abs(c)) {
	      a = c;
	      s = p / 4;
	    } else {
	      s = p / (2 * Math.PI) * Math.asin(c / a);
	    }
	    if (t < 1) {
	      return -0.5 * (a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p)) + b;
	    } else {
	      return a * Math.pow(2, -10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p) * 0.5 + c + b;
	    }
	  },
	  easeInBack: function(t, b, _c, d, s) {
	    var c = _c - b;
	    if (s === void 0) {
	      s = 1.70158;
	    }
	    return c * (t /= d) * t * ((s + 1) * t - s) + b;
	  },
	  easeOutBack: function(t, b, _c, d, s) {
	    var c = _c - b;
	    if (s === void 0) {
	      s = 1.70158;
	    }
	    return c * ((t = t / d - 1) * t * ((s + 1) * t + s) + 1) + b;
	  },
	  easeInOutBack: function(t, b, _c, d, s) {
	    var c = _c - b;
	    if (s === void 0) {
	      s = 1.70158;
	    }
	    if ((t /= d / 2) < 1) {
	      return c / 2 * (t * t * (((s *= 1.525) + 1) * t - s)) + b;
	    } else {
	      return c / 2 * ((t -= 2) * t * (((s *= 1.525) + 1) * t + s) + 2) + b;
	    }
	  },
	  easeInBounce: function(t, b, _c, d) {
	    var c = _c - b;
	    var v;
	    v = tweenFunctions.easeOutBounce(d - t, 0, c, d);
	    return c - v + b;
	  },
	  easeOutBounce: function(t, b, _c, d) {
	    var c = _c - b;
	    if ((t /= d) < 1 / 2.75) {
	      return c * (7.5625 * t * t) + b;
	    } else if (t < 2 / 2.75) {
	      return c * (7.5625 * (t -= 1.5 / 2.75) * t + 0.75) + b;
	    } else if (t < 2.5 / 2.75) {
	      return c * (7.5625 * (t -= 2.25 / 2.75) * t + 0.9375) + b;
	    } else {
	      return c * (7.5625 * (t -= 2.625 / 2.75) * t + 0.984375) + b;
	    }
	  },
	  easeInOutBounce: function(t, b, _c, d) {
	    var c = _c - b;
	    var v;
	    if (t < d / 2) {
	      v = tweenFunctions.easeInBounce(t * 2, 0, c, d);
	      return v * 0.5 + b;
	    } else {
	      v = tweenFunctions.easeOutBounce(t * 2 - d, 0, c, d);
	      return v * 0.5 + c * 0.5 + b;
	    }
	  }
	};

	module.exports = tweenFunctions;


/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _match = __webpack_require__(7);

	var _match2 = _interopRequireDefault(_match);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var tweenGenerator = regeneratorRuntime.mark(function tweenGenerator(_ref) {
	  var _this = this;

	  var duration = _ref.duration;
	  var easing = _ref.easing;
	  var from = _ref.from;
	  var to = _ref.to;

	  var start, _loop;

	  return regeneratorRuntime.wrap(function tweenGenerator$(_context2) {
	    while (1) {
	      switch (_context2.prev = _context2.next) {
	        case 0:
	          start = Date.now();
	          _loop = regeneratorRuntime.mark(function _loop() {
	            var time;
	            return regeneratorRuntime.wrap(function _loop$(_context) {
	              while (1) {
	                switch (_context.prev = _context.next) {
	                  case 0:
	                    time = Date.now() - start;
	                    _context.next = 3;
	                    return (0, _match2.default)(from, to, function (a, b) {
	                      return easing.call(null, time, a, b, duration);
	                    });

	                  case 3:
	                  case 'end':
	                    return _context.stop();
	                }
	              }
	            }, _loop, _this);
	          });

	        case 2:
	          if (!(Date.now() - start < duration)) {
	            _context2.next = 6;
	            break;
	          }

	          return _context2.delegateYield(_loop(), 't0', 4);

	        case 4:
	          _context2.next = 2;
	          break;

	        case 6:
	        case 'end':
	          return _context2.stop();
	      }
	    }
	  }, tweenGenerator, this);
	});

	exports.default = tweenGenerator;

/***/ },
/* 7 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	var match = function match(a, b, func) {
	  if (Array.isArray(a) && Array.isArray(b)) {
	    var result = [];

	    for (var i = 0, l = a.length; i < l; i++) {
	      result.push(match(a[i], b[i], func));
	    }

	    return result;
	  } else if ((typeof a === 'undefined' ? 'undefined' : _typeof(a)) === 'object' && (typeof b === 'undefined' ? 'undefined' : _typeof(b)) === 'object' && a !== null && b !== null) {
	    var result = {};

	    var _iteratorNormalCompletion = true;
	    var _didIteratorError = false;
	    var _iteratorError = undefined;

	    try {
	      for (var _iterator = Object.keys(a)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	        var k = _step.value;

	        result[k] = match(a[k], b[k], func);
	      }
	    } catch (err) {
	      _didIteratorError = true;
	      _iteratorError = err;
	    } finally {
	      try {
	        if (!_iteratorNormalCompletion && _iterator.return) {
	          _iterator.return();
	        }
	      } finally {
	        if (_didIteratorError) {
	          throw _iteratorError;
	        }
	      }
	    }

	    return result;
	  } else if (typeof a === 'number' && typeof b === 'number') {
	    return func(a, b);
	  }

	  return a;
	};

	exports.default = match;

/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.toPath = exports.getPoints = undefined;

	var _getPoints = __webpack_require__(9);

	var _getPoints2 = _interopRequireDefault(_getPoints);

	var _toPath = __webpack_require__(10);

	var _toPath2 = _interopRequireDefault(_toPath);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.getPoints = _getPoints2.default;
	exports.toPath = _toPath2.default;

/***/ },
/* 9 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var getPoints = function getPoints(type, attributes) {
	  switch (type) {
	    case 'circle':
	      return getPointsFromCircle(attributes);
	    case 'ellipse':
	      return getPointsFromEllipse(attributes);
	    case 'line':
	      return getPointsFromLine(attributes);
	    case 'path':
	      return getPointsFromPath(attributes);
	    case 'polygon':
	      return getPointsFromPolygon(attributes);
	    case 'polyline':
	      return getPointsFromPolyline(attributes);
	    case 'rect':
	      return getPointsFromRect(attributes);
	    default:
	      throw new Error('Not a valid shape type');
	  }
	};

	var getPointsFromCircle = function getPointsFromCircle(_ref) {
	  var cx = _ref.cx;
	  var cy = _ref.cy;
	  var r = _ref.r;

	  return [{ x: cx, y: cy - r }, { x: cx, y: cy + r, curve: { type: 'arc', rx: r, ry: r } }, { x: cx, y: cy - r, curve: { type: 'arc', rx: r, ry: r } }];
	};

	var getPointsFromEllipse = function getPointsFromEllipse(_ref2) {
	  var cx = _ref2.cx;
	  var cy = _ref2.cy;
	  var rx = _ref2.rx;
	  var ry = _ref2.ry;

	  return [{ x: cx, y: cy - ry }, { x: cx, y: cy + ry, curve: { type: 'arc', rx: rx, ry: ry } }, { x: cx, y: cy - ry, curve: { type: 'arc', rx: rx, ry: ry } }];
	};

	var getPointsFromLine = function getPointsFromLine(_ref3) {
	  var x1 = _ref3.x1;
	  var x2 = _ref3.x2;
	  var y1 = _ref3.y1;
	  var y2 = _ref3.y2;

	  return [{ x: x1, y: y1 }, { x: x2, y: y2 }];
	};

	var getPointsFromPath = function getPointsFromPath(_ref4) {
	  var d = _ref4.d;

	  var points = [];

	  var instructions = d.split(/[^a-zA-Z]+/).filter(function (i) {
	    return i.length;
	  });
	  var numbers = d.split(/[^\-0-9.]+/).map(parseFloat).filter(function (n) {
	    return !isNaN(n);
	  });

	  var optionalArcKeys = ['xAxisRotation', 'largeArcFlag', 'sweepFlag'];

	  for (var i = 0, l = instructions.length; i < l; i++) {
	    var isFirstPoint = i === 0;
	    var prevPoint = isFirstPoint ? null : points[i - 1];

	    var relative = false;

	    switch (instructions[i]) {
	      case 'm':
	      case 'l':
	        relative = true;

	      case 'M':
	      case 'L':
	        points.push({
	          x: (relative ? prevPoint.x : 0) + numbers.shift(),
	          y: (relative ? prevPoint.y : 0) + numbers.shift()
	        });

	        break;

	      case 'h':
	        relative = true;

	      case 'H':
	        points.push({
	          x: (relative ? prevPoint.x : 0) + numbers.shift(),
	          y: prevPoint.y
	        });

	        break;

	      case 'v':
	        relative = true;

	      case 'V':
	        points.push({
	          x: prevPoint.x,
	          y: (relative ? prevPoint.y : 0) + numbers.shift()
	        });

	        break;

	      case 'a':
	        relative = true;

	      case 'A':
	        points.push({
	          curve: {
	            type: 'arc',
	            rx: numbers.shift(),
	            ry: numbers.shift(),
	            xAxisRotation: numbers.shift(),
	            largeArcFlag: numbers.shift(),
	            sweepFlag: numbers.shift()
	          },
	          x: (relative ? prevPoint.x : 0) + numbers.shift(),
	          y: (relative ? prevPoint.y : 0) + numbers.shift()
	        });

	        var _iteratorNormalCompletion = true;
	        var _didIteratorError = false;
	        var _iteratorError = undefined;

	        try {
	          for (var _iterator = optionalArcKeys[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	            var k = _step.value;

	            if (points[i]['curve'][k] === 0) {
	              delete points[i]['curve'][k];
	            }
	          }
	        } catch (err) {
	          _didIteratorError = true;
	          _iteratorError = err;
	        } finally {
	          try {
	            if (!_iteratorNormalCompletion && _iterator.return) {
	              _iterator.return();
	            }
	          } finally {
	            if (_didIteratorError) {
	              throw _iteratorError;
	            }
	          }
	        }

	        break;

	      case 'c':
	        relative = true;

	      case 'C':
	        points.push({
	          curve: {
	            type: 'cubic',
	            x1: (relative ? prevPoint.x : 0) + numbers.shift(),
	            y1: (relative ? prevPoint.y : 0) + numbers.shift(),
	            x2: (relative ? prevPoint.x : 0) + numbers.shift(),
	            y2: (relative ? prevPoint.y : 0) + numbers.shift()
	          },
	          x: (relative ? prevPoint.x : 0) + numbers.shift(),
	          y: (relative ? prevPoint.y : 0) + numbers.shift()
	        });

	        break;

	      case 's':
	        relative = true;

	      case 'S':
	        var sx2 = (relative ? prevPoint.x : 0) + numbers.shift();
	        var sy2 = (relative ? prevPoint.y : 0) + numbers.shift();
	        var sx = (relative ? prevPoint.x : 0) + numbers.shift();
	        var sy = (relative ? prevPoint.y : 0) + numbers.shift();

	        var diff = {};

	        var sx1 = undefined;
	        var sy1 = undefined;

	        if (prevPoint.curve && prevPoint.curve.type === 'cubic') {
	          diff.x = Math.abs(prevPoint.x - prevPoint.curve.x2);
	          diff.y = Math.abs(prevPoint.y - prevPoint.curve.y2);
	          sx1 = prevPoint.x < prevPoint.curve.x2 ? prevPoint.x - diff.x : prevPoint.x + diff.x;
	          sy1 = prevPoint.y < prevPoint.curve.y2 ? prevPoint.y - diff.y : prevPoint.y + diff.y;
	        } else {
	          diff.x = Math.abs(sx - sx2);
	          diff.y = Math.abs(sy - sy2);
	          sx1 = sx < sx2 ? prevPoint.x - diff.x : prevPoint.x + diff.x;
	          sy1 = sy < sy2 ? prevPoint.y + diff.y : prevPoint.y - diff.y;
	        }

	        points.push({ curve: { type: 'cubic', x1: sx1, y1: sy1, x2: sx2, y2: sy2 }, x: sx, y: sy });

	        break;

	      case 'q':
	        relative = true;

	      case 'Q':
	        points.push({
	          curve: {
	            type: 'quadratic',
	            x1: (relative ? prevPoint.x : 0) + numbers.shift(),
	            y1: (relative ? prevPoint.y : 0) + numbers.shift()
	          },
	          x: (relative ? prevPoint.x : 0) + numbers.shift(),
	          y: (relative ? prevPoint.y : 0) + numbers.shift()
	        });

	        break;

	      case 't':
	        relative = true;

	      case 'T':
	        var tx = (relative ? prevPoint.x : 0) + numbers.shift();
	        var ty = (relative ? prevPoint.y : 0) + numbers.shift();

	        var tx1 = undefined;
	        var ty1 = undefined;

	        if (prevPoint.curve && prevPoint.curve.type === 'quadratic') {
	          var _diff = {
	            x: Math.abs(prevPoint.x - prevPoint.curve.x1),
	            y: Math.abs(prevPoint.y - prevPoint.curve.y1)
	          };

	          tx1 = prevPoint.x < prevPoint.curve.x1 ? prevPoint.x - _diff.x : prevPoint.x + _diff.x;
	          ty1 = prevPoint.y < prevPoint.curve.y1 ? prevPoint.y - _diff.y : prevPoint.y + _diff.y;
	        } else {
	          tx1 = prevPoint.x;
	          ty1 = prevPoint.y;
	        }

	        points.push({ curve: { type: 'quadratic', x1: tx1, y1: ty1 }, x: tx, y: ty });

	        break;

	      case 'z':
	      case 'Z':
	        points.push({ x: points[0].x, y: points[0].y });
	        break;
	    }
	  }

	  return points;
	};

	var getPointsFromPolygon = function getPointsFromPolygon(_ref5) {
	  var points = _ref5.points;

	  return getPointsFromPoints({ closed: true, points: points });
	};

	var getPointsFromPolyline = function getPointsFromPolyline(_ref6) {
	  var points = _ref6.points;

	  return getPointsFromPoints({ closed: false, points: points });
	};

	var getPointsFromPoints = function getPointsFromPoints(_ref7) {
	  var closed = _ref7.closed;
	  var points = _ref7.points;

	  var numbers = points.split(/[\s,]+/).map(function (n) {
	    return parseFloat(n);
	  });

	  var p = numbers.reduce(function (arr, point, i) {
	    if (i % 2 === 0) {
	      arr.push({ x: point });
	    } else {
	      arr[(i - 1) / 2].y = point;
	    }

	    return arr;
	  }, []);

	  if (closed) {
	    p.push(p[0]);
	  }

	  return p;
	};

	var getPointsFromRect = function getPointsFromRect(_ref8) {
	  var height = _ref8.height;
	  var rx = _ref8.rx;
	  var ry = _ref8.ry;
	  var width = _ref8.width;
	  var x = _ref8.x;
	  var y = _ref8.y;

	  if (rx || ry) {
	    return getPointsFromRectWithCornerRadius({
	      height: height,
	      rx: rx ? rx : ry,
	      ry: ry ? ry : rx,
	      width: width,
	      x: x,
	      y: y
	    });
	  }

	  return getPointsFromBasicRect({ height: height, width: width, x: x, y: y });
	};

	var getPointsFromBasicRect = function getPointsFromBasicRect(_ref9) {
	  var height = _ref9.height;
	  var width = _ref9.width;
	  var x = _ref9.x;
	  var y = _ref9.y;

	  return [{ x: x, y: y }, { x: x + width, y: y }, { x: x + width, y: y + height }, { x: x, y: y + height }, { x: x, y: y }];
	};

	var getPointsFromRectWithCornerRadius = function getPointsFromRectWithCornerRadius(_ref10) {
	  var height = _ref10.height;
	  var rx = _ref10.rx;
	  var ry = _ref10.ry;
	  var width = _ref10.width;
	  var x = _ref10.x;
	  var y = _ref10.y;

	  var curve = { type: 'arc', rx: rx, ry: ry, sweepFlag: 1 };

	  return [{ x: x + rx, y: y }, { x: x + width - rx, y: y }, { x: x + width, y: y + ry, curve: curve }, { x: x + width, y: y + height - ry }, { x: x + width - rx, y: y + height, curve: curve }, { x: x + rx, y: y + height }, { x: x, y: y + height - ry, curve: curve }, { x: x, y: y + ry }, { x: x + rx, y: y, curve: curve }];
	};

	exports.default = getPoints;

/***/ },
/* 10 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var toPath = function toPath(points) {
	  var d = '';
	  var i = 0;

	  var firstPoint = points[i];

	  var _iteratorNormalCompletion = true;
	  var _didIteratorError = false;
	  var _iteratorError = undefined;

	  try {
	    for (var _iterator = points[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	      var point = _step.value;

	      var isFirstPoint = i === 0;
	      var isLastPoint = i === points.length - 1;
	      var prevPoint = isFirstPoint ? null : points[i - 1];
	      var _point$curve = point.curve;
	      var curve = _point$curve === undefined ? false : _point$curve;
	      var x = point.x;
	      var y = point.y;


	      if (isFirstPoint) {
	        d += 'M' + x + ',' + y;
	      } else if (curve) {
	        switch (curve.type) {
	          case 'arc':
	            var _point$curve2 = point.curve;
	            var _point$curve2$largeAr = _point$curve2.largeArcFlag;
	            var largeArcFlag = _point$curve2$largeAr === undefined ? 0 : _point$curve2$largeAr;
	            var rx = _point$curve2.rx;
	            var ry = _point$curve2.ry;
	            var _point$curve2$sweepFl = _point$curve2.sweepFlag;
	            var sweepFlag = _point$curve2$sweepFl === undefined ? 0 : _point$curve2$sweepFl;
	            var _point$curve2$xAxisRo = _point$curve2.xAxisRotation;
	            var xAxisRotation = _point$curve2$xAxisRo === undefined ? 0 : _point$curve2$xAxisRo;

	            d += 'A' + rx + ',' + ry + ',' + xAxisRotation + ',' + largeArcFlag + ',' + sweepFlag + ',' + x + ',' + y;
	            break;
	          case 'cubic':
	            var _point$curve3 = point.curve;
	            var cx1 = _point$curve3.x1;
	            var cy1 = _point$curve3.y1;
	            var cx2 = _point$curve3.x2;
	            var cy2 = _point$curve3.y2;

	            d += 'C' + cx1 + ',' + cy1 + ',' + cx2 + ',' + cy2 + ',' + x + ',' + y;
	            break;
	          case 'quadratic':
	            var _point$curve4 = point.curve;
	            var qx1 = _point$curve4.x1;
	            var qy1 = _point$curve4.y1;

	            d += 'Q' + qx1 + ',' + qy1 + ',' + x + ',' + y;
	            break;
	        }

	        if (isLastPoint && x === firstPoint.x && y === firstPoint.y) {
	          d += 'Z';
	        }
	      } else if (isLastPoint && x === firstPoint.x && y === firstPoint.y) {
	        d += 'Z';
	      } else if (x !== prevPoint.x && y !== prevPoint.y) {
	        d += 'L' + x + ',' + y;
	      } else if (x !== prevPoint.x) {
	        d += 'H' + x;
	      } else if (y !== prevPoint.y) {
	        d += 'V' + y;
	      }

	      i++;
	    }
	  } catch (err) {
	    _didIteratorError = true;
	    _iteratorError = err;
	  } finally {
	    try {
	      if (!_iteratorNormalCompletion && _iterator.return) {
	        _iterator.return();
	      }
	    } finally {
	      if (_didIteratorError) {
	        throw _iteratorError;
	      }
	    }
	  }

	  return d;
	};

	exports.default = toPath;

/***/ },
/* 11 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.removePoints = exports.addPoints = undefined;

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	var _svgArcToCubicBezier = __webpack_require__(12);

	var _svgArcToCubicBezier2 = _interopRequireDefault(_svgArcToCubicBezier);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

	var isBetween = function isBetween(a, b, c) {
	  if (b.curve || c.curve) {
	    return false;
	  }

	  var crossProduct = (c.y - a.y) * (b.x - a.x) - (c.x - a.x) * (b.y - a.y);

	  if (Math.abs(crossProduct) > Number.EPSILON) {
	    return false;
	  }

	  var dotProduct = (c.x - a.x) * (b.x - a.x) + (c.y - a.y) * (b.y - a.y);

	  if (dotProduct < 0) {
	    return false;
	  }

	  var squaredLengthBA = (b.x - a.x) * (b.x - a.x) + (b.y - a.y) * (b.y - a.y);

	  if (dotProduct > squaredLengthBA) {
	    return false;
	  }

	  return true;
	};

	var straightMidPoint = function straightMidPoint(a, b) {
	  var x = a.x === b.x ? 0 : Math.abs(b.x - a.x);
	  var y = a.y === b.y ? 0 : Math.abs(b.y - a.y);

	  return {
	    x: x === 0 ? a.x : a.x < b.x ? a.x + x / 2 : a.x - x / 2,
	    y: y === 0 ? a.y : a.y < b.y ? a.y + y / 2 : a.y - y / 2
	  };
	};

	var midPoint = function midPoint(a, b) {
	  if (!b.curve) {
	    return straightMidPoint(a, b);
	  }

	  return false;
	};

	var addPoints = function addPoints(points, pointsRequired) {
	  var p = [].concat(_toConsumableArray(points));

	  for (var i = 1; i < p.length;) {
	    var m = midPoint(p[i - 1], p[i]);

	    if (m) {
	      p.splice(i, 0, m);

	      if (p.length === pointsRequired) {
	        return p;
	      }

	      i += 2;
	    } else {
	      i++;
	    }
	  }

	  if (p.length === points.length) {
	    var additionalPoints = pointsRequired - p.length;
	    var newPoint = { x: p[0].x, y: p[0].y };

	    for (var _i = 0; _i < additionalPoints; _i++) {
	      p.unshift(newPoint);
	    }

	    return p;
	  }

	  return addPoints(p, pointsRequired);
	};

	var removePoints = function removePoints(points) {
	  var result = [];

	  for (var i = 0, l = points.length; i < l; i++) {
	    var a = result[result.length - 1];
	    var b = points[i + 1];
	    var c = points[i];

	    if (!(a && b && c) || !isBetween(a, b, c)) {
	      result.push(c);
	    }
	  }

	  return result;
	};

	var matchCurves = function matchCurves(a, b) {
	  var c = [];
	  var d = [];

	  for (var i = 0, l = a.length; i < l; i++) {
	    if (a[i].curve && !b[i].curve) {
	      c.push(a[i]);
	      d.push(_extends({}, b[i], { curve: {
	          type: 'cubic',
	          x1: b[i - 1].x,
	          y1: b[i - 1].y,
	          x2: b[i].x,
	          y2: b[i].y
	        } }));
	    } else if (b[i].curve && !a[i].curve) {
	      d.push(b[i]);
	      c.push(_extends({}, a[i], { curve: {
	          type: 'cubic',
	          x1: a[i - 1].x,
	          y1: a[i - 1].y,
	          x2: a[i].x,
	          y2: a[i].y
	        } }));
	    } else {
	      c.push(a[i]);
	      d.push(b[i]);
	    }
	  }

	  return [c, d];
	};

	var convertCurvesToCubic = function convertCurvesToCubic(points) {
	  var p = [];

	  for (var i = 0, l = points.length; i < l; i++) {
	    var point = points[i];

	    if (point.curve && point.curve.type !== 'cubic') {
	      var _points = points[i - 1];
	      var px = _points.x;
	      var py = _points.y;
	      var cx = point.x;
	      var cy = point.y;


	      if (point.curve.type === 'arc') {
	        var curves = (0, _svgArcToCubicBezier2.default)({
	          px: px,
	          py: py,
	          cx: cx,
	          cy: cy,
	          rx: point.curve.rx,
	          ry: point.curve.ry,
	          xAxisRotation: point.curve.xAxisRotation,
	          largeArcFlag: point.curve.largeArcFlag,
	          sweepFlag: point.curve.sweepFlag
	        });

	        curves.forEach(function (_ref) {
	          var x1 = _ref.x1;
	          var y1 = _ref.y1;
	          var x2 = _ref.x2;
	          var y2 = _ref.y2;
	          var x = _ref.x;
	          var y = _ref.y;

	          p.push({ x: x, y: y, curve: { type: 'cubic', x1: x1, y1: y1, x2: x2, y2: y2 } });
	        });
	      } else if (point.curve.type === 'quadratic') {
	        var x1 = px + 2 / 3 * (point.curve.x1 - px);
	        var y1 = py + 2 / 3 * (point.curve.y1 - py);
	        var x2 = cx + 2 / 3 * (point.curve.x1 - cx);
	        var y2 = cy + 2 / 3 * (point.curve.y1 - cy);

	        p.push({ x: cx, y: cy, curve: { type: 'cubic', x1: x1, y1: y1, x2: x2, y2: y2 } });
	      }
	    } else {
	      p.push(point);
	    }
	  }

	  return p;
	};

	var matchPoints = function matchPoints(a, b) {
	  var c = convertCurvesToCubic(removePoints(a));
	  var d = convertCurvesToCubic(removePoints(b));

	  if (d.length > c.length) {
	    c = addPoints(c, d.length);
	  } else if (c.length > d.length) {
	    d = addPoints(d, c.length);
	  }

	  return matchCurves(c, d);
	};

	exports.addPoints = addPoints;
	exports.removePoints = removePoints;
	exports.default = matchPoints;

/***/ },
/* 12 */
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

	var TAU = Math.PI * 2;

	var mapToEllipse = function mapToEllipse(_ref, rx, ry, cosphi, sinphi, centerx, centery) {
	  var x = _ref.x;
	  var y = _ref.y;

	  x *= rx;
	  y *= ry;

	  var xp = cosphi * x - sinphi * y;
	  var yp = sinphi * x + cosphi * y;

	  return {
	    x: xp + centerx,
	    y: yp + centery
	  };
	};

	var approxUnitArc = function approxUnitArc(ang1, ang2) {
	  var a = 4 / 3 * Math.tan(ang2 / 4);

	  var x1 = Math.cos(ang1);
	  var y1 = Math.sin(ang1);
	  var x2 = Math.cos(ang1 + ang2);
	  var y2 = Math.sin(ang1 + ang2);

	  return [{
	    x: x1 - y1 * a,
	    y: y1 + x1 * a
	  }, {
	    x: x2 + y2 * a,
	    y: y2 - x2 * a
	  }, {
	    x: x2,
	    y: y2
	  }];
	};

	var vectorAngle = function vectorAngle(ux, uy, vx, vy) {
	  var sign = ux * vy - uy * vx < 0 ? -1 : 1;
	  var umag = Math.sqrt(ux * ux + uy * uy);
	  var vmag = Math.sqrt(ux * ux + uy * uy);
	  var dot = ux * vx + uy * vy;

	  var div = dot / (umag * vmag);

	  if (div > 1) {
	    div = 1;
	  }

	  if (div < -1) {
	    div = -1;
	  }

	  return sign * Math.acos(div);
	};

	var getArcCenter = function getArcCenter(px, py, cx, cy, rx, ry, largeArcFlag, sweepFlag, sinphi, cosphi, pxp, pyp) {
	  var rxsq = Math.pow(rx, 2);
	  var rysq = Math.pow(ry, 2);
	  var pxpsq = Math.pow(pxp, 2);
	  var pypsq = Math.pow(pyp, 2);

	  var radicant = rxsq * rysq - rxsq * pypsq - rysq * pxpsq;

	  if (radicant < 0) {
	    radicant = 0;
	  }

	  radicant /= rxsq * pypsq + rysq * pxpsq;
	  radicant = Math.sqrt(radicant) * (largeArcFlag === sweepFlag ? -1 : 1);

	  var centerxp = radicant * rx / ry * pyp;
	  var centeryp = radicant * -ry / rx * pxp;

	  var centerx = cosphi * centerxp - sinphi * centeryp + (px + cx) / 2;
	  var centery = sinphi * centerxp + cosphi * centeryp + (py + cy) / 2;

	  var vx1 = (pxp - centerxp) / rx;
	  var vy1 = (pyp - centeryp) / ry;
	  var vx2 = (-pxp - centerxp) / rx;
	  var vy2 = (-pyp - centeryp) / ry;

	  var ang1 = vectorAngle(1, 0, vx1, vy1);
	  var ang2 = vectorAngle(vx1, vy1, vx2, vy2);

	  if (sweepFlag === 0 && ang2 > 0) {
	    ang2 -= TAU;
	  }

	  if (sweepFlag === 1 && ang2 < 0) {
	    ang2 += TAU;
	  }

	  return [centerx, centery, ang1, ang2];
	};

	var arcToBezier = function arcToBezier(_ref2) {
	  var px = _ref2.px;
	  var py = _ref2.py;
	  var cx = _ref2.cx;
	  var cy = _ref2.cy;
	  var rx = _ref2.rx;
	  var ry = _ref2.ry;
	  var _ref2$xAxisRotation = _ref2.xAxisRotation;
	  var xAxisRotation = _ref2$xAxisRotation === undefined ? 0 : _ref2$xAxisRotation;
	  var _ref2$largeArcFlag = _ref2.largeArcFlag;
	  var largeArcFlag = _ref2$largeArcFlag === undefined ? 0 : _ref2$largeArcFlag;
	  var _ref2$sweepFlag = _ref2.sweepFlag;
	  var sweepFlag = _ref2$sweepFlag === undefined ? 0 : _ref2$sweepFlag;

	  var curves = [];

	  if (rx === 0 || ry === 0) {
	    return [];
	  }

	  var sinphi = Math.sin(xAxisRotation * TAU / 360);
	  var cosphi = Math.cos(xAxisRotation * TAU / 360);

	  var pxp = cosphi * (px - cx) / 2 + sinphi * (py - cy) / 2;
	  var pyp = -sinphi * (px - cx) / 2 + cosphi * (py - cy) / 2;

	  if (pxp === 0 && pyp === 0) {
	    return [];
	  }

	  rx = Math.abs(rx);
	  ry = Math.abs(ry);

	  var lambda = Math.pow(pxp, 2) / Math.pow(rx, 2) + Math.pow(pyp, 2) / Math.pow(ry, 2);

	  if (lambda > 1) {
	    rx *= Math.sqrt(lambda);
	    ry *= Math.sqrt(lambda);
	  }

	  var _getArcCenter = getArcCenter(px, py, cx, cy, rx, ry, largeArcFlag, sweepFlag, sinphi, cosphi, pxp, pyp);

	  var _getArcCenter2 = _slicedToArray(_getArcCenter, 4);

	  var centerx = _getArcCenter2[0];
	  var centery = _getArcCenter2[1];
	  var ang1 = _getArcCenter2[2];
	  var ang2 = _getArcCenter2[3];


	  var segments = Math.max(Math.ceil(Math.abs(ang2) / (TAU / 4)), 1);

	  ang2 /= segments;

	  for (var i = 0; i < segments; i++) {
	    curves.push(approxUnitArc(ang1, ang2));
	    ang1 += ang2;
	  }

	  return curves.map(function (curve) {
	    var _mapToEllipse = mapToEllipse(curve[0], rx, ry, cosphi, sinphi, centerx, centery);

	    var x1 = _mapToEllipse.x;
	    var y1 = _mapToEllipse.y;

	    var _mapToEllipse2 = mapToEllipse(curve[1], rx, ry, cosphi, sinphi, centerx, centery);

	    var x2 = _mapToEllipse2.x;
	    var y2 = _mapToEllipse2.y;

	    var _mapToEllipse3 = mapToEllipse(curve[2], rx, ry, cosphi, sinphi, centerx, centery);

	    var x = _mapToEllipse3.x;
	    var y = _mapToEllipse3.y;


	    return { x1: x1, y1: y1, x2: x2, y2: y2, x: x, y: y };
	  });
	};

	exports.default = arcToBezier;

/***/ }
/******/ ])
});
;