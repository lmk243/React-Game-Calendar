'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
var toPath = function toPath(points) {
  var d = '';
  var i = 0;

  var firstPoint = points[i];

  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = points[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var point = _step.value;

      var isFirstPoint = i === 0;
      var isLastPoint = i === points.length - 1;
      var prevPoint = isFirstPoint ? null : points[i - 1];
      var _point$curve = point.curve;
      var curve = _point$curve === undefined ? false : _point$curve;
      var x = point.x;
      var y = point.y;


      if (isFirstPoint) {
        d += 'M' + x + ',' + y;
      } else if (curve) {
        switch (curve.type) {
          case 'arc':
            var _point$curve2 = point.curve;
            var _point$curve2$largeAr = _point$curve2.largeArcFlag;
            var largeArcFlag = _point$curve2$largeAr === undefined ? 0 : _point$curve2$largeAr;
            var rx = _point$curve2.rx;
            var ry = _point$curve2.ry;
            var _point$curve2$sweepFl = _point$curve2.sweepFlag;
            var sweepFlag = _point$curve2$sweepFl === undefined ? 0 : _point$curve2$sweepFl;
            var _point$curve2$xAxisRo = _point$curve2.xAxisRotation;
            var xAxisRotation = _point$curve2$xAxisRo === undefined ? 0 : _point$curve2$xAxisRo;

            d += 'A' + rx + ',' + ry + ',' + xAxisRotation + ',' + largeArcFlag + ',' + sweepFlag + ',' + x + ',' + y;
            break;
          case 'cubic':
            var _point$curve3 = point.curve;
            var cx1 = _point$curve3.x1;
            var cy1 = _point$curve3.y1;
            var cx2 = _point$curve3.x2;
            var cy2 = _point$curve3.y2;

            d += 'C' + cx1 + ',' + cy1 + ',' + cx2 + ',' + cy2 + ',' + x + ',' + y;
            break;
          case 'quadratic':
            var _point$curve4 = point.curve;
            var qx1 = _point$curve4.x1;
            var qy1 = _point$curve4.y1;

            d += 'Q' + qx1 + ',' + qy1 + ',' + x + ',' + y;
            break;
        }

        if (isLastPoint && x === firstPoint.x && y === firstPoint.y) {
          d += 'Z';
        }
      } else if (isLastPoint && x === firstPoint.x && y === firstPoint.y) {
        d += 'Z';
      } else if (x !== prevPoint.x && y !== prevPoint.y) {
        d += 'L' + x + ',' + y;
      } else if (x !== prevPoint.x) {
        d += 'H' + x;
      } else if (y !== prevPoint.y) {
        d += 'V' + y;
      }

      i++;
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  return d;
};

exports.default = toPath;